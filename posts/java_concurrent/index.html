<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.123.7">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title> &middot; My New Hugo Site</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="http://XxRa1n.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="http://XxRa1n.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="http://XxRa1n.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="http://XxRa1n.github.io/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://XxRa1n.github.io/"><h1>My New Hugo Site</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="http://XxRa1n.github.io/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2024. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1></h1>
  <time datetime=0001-01-01T00:00:00Z class="post-date">Mon, Jan 1, 0001</time>
  <p>title: &ldquo;Java 并发编程&rdquo;
date: 2023-12-17 18:00:00 +0800
author: me
cover: &ldquo;-/images/example.png&rdquo;
tags:
- 代码
- web</p>
<hr>
<h1 id="一创建线程">一.创建线程</h1>
<p>方法1：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#75715e">//创建线程</span>
</span></span><span style="display:flex;"><span>Thread t <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//do something</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>t.<span style="color:#a6e22e">setName</span>(<span style="color:#e6db74">&#34;线程名&#34;</span>);<span style="color:#75715e">//设置线程名</span>
</span></span><span style="display:flex;"><span>t.<span style="color:#a6e22e">start</span>();<span style="color:#75715e">//启动线程</span>
</span></span></code></pre></div><p>方法2：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span>Runnable runnable <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Runnable(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//do something</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//创建线程并设置线程名称</span>
</span></span><span style="display:flex;"><span>Thread t <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(runnable,<span style="color:#e6db74">&#34;线程名&#34;</span>)
</span></span><span style="display:flex;"><span>t.<span style="color:#a6e22e">start</span>();<span style="color:#75715e">//启动线程</span>
</span></span></code></pre></div><p>使用lambda表达式简化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span>Runnable runnable <span style="color:#f92672">=</span> () <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//do something</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//创建线程并设置线程名称</span>
</span></span><span style="display:flex;"><span>Thread t <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(runnable,<span style="color:#e6db74">&#34;线程名&#34;</span>)
</span></span><span style="display:flex;"><span>t.<span style="color:#a6e22e">start</span>();<span style="color:#75715e">//启动线程</span>
</span></span></code></pre></div><p>方法3：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span>FutureTask<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> task <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FutureTask<span style="color:#f92672">&lt;&gt;</span>(<span style="color:#66d9ef">new</span> Callable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">call</span>() <span style="color:#66d9ef">throws</span> Exception {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//do something</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>Thread thread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(task,<span style="color:#e6db74">&#34;线程名&#34;</span>);
</span></span><span style="display:flex;"><span>t.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> returnValue <span style="color:#f92672">=</span> task.<span style="color:#a6e22e">get</span>();
</span></span></code></pre></div><h1 id="二线程运行的原理">二.线程运行的原理</h1>
<p><strong>1.存储位置：</strong>
JVM由栈内存、堆内存和方法区组成。
栈内存：由栈帧组成，存储局部变量表和线程信息等
堆内存：存储对象实例
方法区：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p><strong>2.栈帧：</strong>
包括main线程的每一个线程都在栈内存中占用一个栈帧，栈帧遵循后进先出原则</p>
<p><strong>3.线程的上下文切换：</strong>
cpu轮转调度不同线程时，需要记录线程的运行状态，以便下次再切换回这个线程时，可以知道该线程在上次运行到哪了。</p>
<h1 id="三线程的方法">三.线程的方法</h1>
<pre tabindex="0"><code>start() //启动一个新的线程，并运行run()方法
run()   //新线程启动后会调用的方法
join()  //等待线程运行结束
sleep(long n) //让当前正在执行的线程暂停一段时间
yield() //暂停当前正在执行的线程对象，并执行其他线程
getId() //获取线程的唯一标识
getName()//获取线程的名称
setName()//设置线程的名称
getPriority()//获取线程的优先级
setPriority()//设置线程的优先级
getStatus()//获取线程的状态
interrupt()//中断线程
</code></pre><h2 id="31-sleep与yield">3.1 sleep与yield</h2>
<p><strong>sleep:</strong></p>
<ol>
<li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</li>
<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>
<li>睡眠结束后的线程未必会立刻得到执行</li>
<li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li>
</ol>
<p><strong>yield:</strong></p>
<ol>
<li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</li>
<li>具体的实现依赖于操作系统的任务调度器</li>
</ol>
<p><strong>线程优先级：</strong></p>
<ul>
<li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li>
<li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li>
</ul>
<h2 id="32-interrupt打断">3.2 Interrupt打断</h2>
<p>打断sleep,join,wait的线程(处于阻塞态的线程)</p>
<p><strong>Interrupted标志：</strong></p>
<ul>
<li>正在运行的Thread在被Interrupt后会自动将Interrupted标志位置为true，然后通过isInterrupted()方法可以获取到该标志位。
通过这种方法可以检测到线程是否被Interrupt，从而进行相应的处理。</li>
<li>处于sleep,join,wait的线程被打断后，Interrupted不会改变为false。</li>
</ul>
<p>interrupt() 方法可以将线程从以下两种状态中转换到另外两种状态：</p>
<ul>
<li>
<p>阻塞状态（Blocked）：如果线程处于阻塞状态（如调用了 Object.wait()、Thread.sleep()、Thread.join() 等方法），调用 interrupt() 方法会使线程抛出 InterruptedException 异常，并清除线程的中断状态。这样可以提前终止线程的阻塞状态，使线程可以继续执行或者退出。</p>
</li>
<li>
<p>可运行状态（Runnable）：如果线程处于可运行状态（正在运行或者等待 CPU 资源），调用 interrupt() 方法只是设置线程的中断状态为 true，并不会中断线程的执行。目标线程可以在适当的时候检查自身的中断状态并做出响应，比如停止执行并退出。</p>
</li>
</ul>
<h4 id="两阶段终止">两阶段终止：</h4>
<p>两阶段终止描述的就是T1线程如何“优雅”地终止T2线程。
<strong>错误思路：</strong>
直接调用<code>stop()</code>来终止线程。<code>stop()</code>会立即停止线程，并锁定该线程调用的公共资源。导致这些资源永远无法被释放。
<strong>两阶段终止图示：</strong>
<img src="./images/java_concurrent_interrupt.png" alt="">
核心机制就是调用interrupt()方法,通过改变interrupted标志位来判断是否结束进线程。</p>
<p><strong>park()方法：</strong> 可以通过interrupt()方法打断park()方法
park() 方法是 java.util.concurrent.locks.LockSupport 类中的一个方法，用于线程的阻塞，它的作用是使当前线程暂停执行，进入等待状态，直到被显式地唤醒或者被中断。
具体来说，park() 方法会禁用当前线程，使其进入等待状态，直到发生以下三种情况之一：</p>
<ul>
<li>其他线程调用了当前线程的 unpark() 方法，并且给定了当前线程作为参数。</li>
<li>其他线程中断了当前线程。即调用interrupt()方法。</li>
<li>出现 &ldquo;虚假唤醒&rdquo;，即线程被唤醒但没有明确的原因。</li>
</ul>
<p><strong>不推荐使用的方法：</strong></p>
<ul>
<li>stop():停止线程运行</li>
<li>suspend()：挂起(暂停)线程运行</li>
<li>resume()：恢复线程运行</li>
</ul>
<blockquote>
<p>线程安全的类型：
String
Integer
StringBuffer
Random
Vector
Hashtable
java.util.concurrent 包下的类
<strong>线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。</strong></p>
</blockquote>
<h1 id="四主线程与守护线程">四.主线程与守护线程</h1>
<p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做<strong>守护线程</strong>，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p>
<blockquote>
<p>垃圾回收器就是一种守护线程</p>
</blockquote>
<h1 id="五线程的状态">五.线程的状态</h1>
<p><strong>操作系统</strong>层面可以分为5种状态：</p>
<ul>
<li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</li>
<li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li>
<li>【运行状态】指获取了 CPU 时间片运行中的状态
<ul>
<li>当 CPU 时间片用完，会从【运行状态】转换至 【可运行状态】，会导致线程的上下文切换</li>
</ul>
</li>
<li>【阻塞状态】
<ul>
<li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】</li>
<li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑
调度它们</li>
</ul>
</li>
<li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li>
</ul>
<p><strong>JavaAPI</strong>层面可以分为六种状态：
根据 Thread.State 枚举，分为六种状态。</p>
<ul>
<li>NEW 线程刚被创建，但是还没有调用 start() 方法</li>
<li>RUNNABLE 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的
【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为
是可运行）</li>
<li>BLOCKED ， WAITING ， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节
详述</li>
<li>TERMINATED 当线程代码运行结束</li>
</ul>
<h1 id="六共享模型管理">六.共享模型管理</h1>
<p>实现互斥访问的方案：</p>
<ul>
<li>阻塞式的解决方案:synchronized,Lock</li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
<h3 id="61-synchronized">6.1 synchronized</h3>
<p>synchronized，俗称【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p>
<h4 id="611-基本用法">6.1.1 基本用法</h4>
<p><strong>语法：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">synchronized</span>(对象) <span style="color:#75715e">// 对象是互斥访问的公共资源</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> 临界区
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以在类中实现原子化操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Room</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> value <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">increment</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> (<span style="color:#66d9ef">this</span>) {
</span></span><span style="display:flex;"><span>        value<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">decrement</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> (<span style="color:#66d9ef">this</span>) {
</span></span><span style="display:flex;"><span>        value<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> (<span style="color:#66d9ef">this</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> value;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="612-synchronized用在方法上">6.1.2 synchronized用在方法上</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>等价于</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span>(<span style="color:#66d9ef">this</span>){
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="613-synchronized用在静态方法上">6.1.3 synchronized用在静态方法上</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>等价于</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span>(Test.<span style="color:#a6e22e">class</span>){
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="614-变量线程安全分析">6.1.4 变量线程安全分析</h4>
<h4 id="615-monitor">6.1.5 monitor</h4>
<h4 id="616-waitnotify">6.1.6 wait/notify</h4>
<p>常用方法:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span>obj.<span style="color:#a6e22e">wait</span>()      <span style="color:#75715e">//让进入object监视器的线程到waitSet等待</span>
</span></span><span style="display:flex;"><span>obj.<span style="color:#a6e22e">wait</span>(<span style="color:#66d9ef">long</span> timeout)      <span style="color:#75715e">//让进入object监视器的线程到waitSet等待,等待最长时间timeout。超过timeout则自动唤醒</span>
</span></span><span style="display:flex;"><span>obj.<span style="color:#a6e22e">notify</span>()    <span style="color:#75715e">//在object上正在waitSet等待的线程中挑一个唤醒</span>
</span></span><span style="display:flex;"><span>obj.<span style="color:#a6e22e">notifyAll</span>() <span style="color:#75715e">//让object上正在waitSet等待的线程全部唤醒</span>
</span></span></code></pre></div><p>使用wait/notify的前提是各个线程之间需要获得该对象的锁</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">synchronized</span>(obj){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>       obj.<span style="color:#a6e22e">wait</span>(); 
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>        e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用泛式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#75715e">// Thread A</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">synchronized</span>(lock){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(条件不满足){
</span></span><span style="display:flex;"><span>        lock.<span style="color:#a6e22e">wait</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 业务逻辑</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Thread B</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">synchronized</span>(lock){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 修改Thread A中的判定条件</span>
</span></span><span style="display:flex;"><span>    lock.<span style="color:#a6e22e">notifyAll</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="617-wait和sleep的区别">6.1.7 wait和sleep的区别</h4>
<ul>
<li>sleep 是 Thread 方法，而 wait 是 Object 的方法</li>
<li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用</li>
<li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</li>
<li>它们的状态都是TIMED_WAITING</li>
</ul>
<h1 id="七设计模型">七.设计模型</h1>
<h2 id="71-保护性暂停同步模式">7.1 保护性暂停[同步模式]</h2>
<p>Guarded Suspension,用在一个线程等待另一个线程的执行结果时。</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个GuardedObject</li>
<li>如果有结果需要不断从一个线程到另一个线程那么可以使用消息队列(见生产者/消费者)</li>
</ul>
<p>// 把视频中的示例代码copy下来</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GuardedObject</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Object response;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">get</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span>(<span style="color:#66d9ef">this</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(response <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">wait</span>();
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                    e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> response;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">complete</span>(Object response){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span>(<span style="color:#66d9ef">this</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">response</span> <span style="color:#f92672">=</span> response;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">notifyAll</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>// 虚假唤醒</p>
<h2 id="72-生产者-消费者异步模式">7.2 生产者-消费者[异步模式]</h2>
<ul>
<li>与保护性暂停模式GuardObject不同，生产者消费者模型不需要产生和消费的线程一一对应，消费队列可以用来平衡生产和消费的线程资源</li>
<li>生产者仅负责产生结果数据，不关心数据如何处理，而消费者专心处理结果数据</li>
<li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li>
</ul>
<h2 id="73-固定运行顺序">7.3 固定运行顺序</h2>
<p>用boolean值变量控制执行顺序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">boolean</span> turn <span style="color:#f92672">=</span> True;
</span></span><span style="display:flex;"><span>Object lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object();
</span></span><span style="display:flex;"><span>Thread t1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>(){
</span></span><span style="display:flex;"><span>        sychronized(lock){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(turn){
</span></span><span style="display:flex;"><span>                lock.<span style="color:#a6e22e">wait</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;1&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Thread t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>(){
</span></span><span style="display:flex;"><span>        sychronized(lock){
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;2&#34;</span>);
</span></span><span style="display:flex;"><span>            turn <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            lock.<span style="color:#a6e22e">notifyAll</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="74-交替输出">7.4 交替输出</h2>
<p>// code p130-p132</p>
<p>// code P107</p>
<h2 id="parkunpark">Park&amp;Unpark</h2>
<p>LockSupport类中的方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span>LockSupport.<span style="color:#a6e22e">park</span>() <span style="color:#75715e">//阻塞当前线程</span>
</span></span><span style="display:flex;"><span>LockSupport.<span style="color:#a6e22e">unpark</span>(Thread thread) <span style="color:#75715e">//唤醒处于阻塞状态的线程</span>
</span></span></code></pre></div><h2 id="reentrantlock">ReentrantLock</h2>
<p>与synchronized相比，ReentrantLock具有如下特点：</p>
<ul>
<li>可中断Block状态lockInterruptable():无法获取资源的线程会自动进入BLOCK状态，其他线程可以interrupt该线程的BLOCK状态，抛出异常。</li>
<li>可以设置超时时间tryLock():等待一段时间后自动interrupt</li>
<li>可以设置为公平锁(防止线程饥饿)ReentrantLock(True):争抢锁的时候，先到先得。<strong>但是会降低并发度！</strong></li>
<li>支持多个条件变量(分别唤醒):</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span>ReentrantLock lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantLock();
</span></span><span style="display:flex;"><span>Condition c1 <span style="color:#f92672">=</span> lock.<span style="color:#a6e22e">newCondition</span>();
</span></span><span style="display:flex;"><span>Condition c2 <span style="color:#f92672">=</span> lock.<span style="color:#a6e22e">newCondition</span>();
</span></span><span style="display:flex;"><span>lock.<span style="color:#a6e22e">lock</span>();
</span></span><span style="display:flex;"><span>c1.<span style="color:#a6e22e">await</span>();
</span></span><span style="display:flex;"><span>c1.<span style="color:#a6e22e">signal</span>();
</span></span><span style="display:flex;"><span>c1.<span style="color:#a6e22e">signalAll</span>();
</span></span></code></pre></div><p>synchronized和ReentrantLock都可重入</p>
<blockquote>
<p>可重入：线程可以重复获取同一个锁</p>
</blockquote>
<h3 id="reentrantlock语法">ReentrantLock语法</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span>reentrantLock.<span style="color:#a6e22e">lock</span>() <span style="color:#75715e">//加锁</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 临界区</span>
</span></span><span style="display:flex;"><span>}<span style="color:#66d9ef">finally</span>{
</span></span><span style="display:flex;"><span>    reentrantLock.<span style="color:#a6e22e">unlock</span>() <span style="color:#75715e">//解锁</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="八-java-memory-model-jmm">八. Java Memory Model (JMM)</h1>
<ul>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ul>
<h2 id="81-java内存模型">8.1 Java内存模型</h2>
<ul>
<li>主存：线程之间共享</li>
<li>工作内存：线程私有</li>
</ul>
<h1 id="附录">附录</h1>
<p>跳过的章节：
所有练习章节都跳过了
线程安全分析skip
synchronized优化原理skip</p>

</div>


    </main>

    
      
    
  </body>
</html>
